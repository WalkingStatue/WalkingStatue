**Chapter 1**

*Software can be described as a collection of
instruction that are executed to get desired
functionalities.

Software is made-up of
-instructions provide desired function and performance
-data structures manipulate information
-documents use of the programs


*Types of Software

■ system software
■ application software
■ engineering/scientific software
■ embedded software
■ product-line software (word
processing, spread sheet)
■ WebApps (Web applications)
■ AI software (solve better than
human)
■ Open world computing
■ Netsourcing
■ Open source


*Characteristics of Software

􀀀 Not “Manufactured” in the Classical Sense
􀀀 A logical rather than physical system element
􀀀 Invisibility
􀀀 Does Not “Wear-Out”
􀀀 Invariably Custom-Built
􀀀 Has reusable components
􀀀 Flexible


*Software Engineering

IEEE Definition
“A Systematic Approach to the Development,
Operation, Maintenance and Retirement of
Software, where Software is Computer
Programs, Procedures, Rules and Associated
Documents and Data pertaining to the Operation
of a Computer System.”


*Software Engineering Layers

![[Pasted image 20231211142018.png]]

■ Engg. Approach must rest on quality
■ Process manage and control s/w projects and
delivery of quality work products
■ Method provide technical how-to’s for
communication, requirements analysis, design
modeling, program construction, testing …
■ Tools provide automated and semi automated
support for the process and methods


*The Software Process

Software Process is the Collection of Activities ,Actions
and Tasks , that are performed when some work
product is to be created

A process frame work establishes the foundation for a
complete software engineering process by identifying a
small number of a framework activities , applicable to all
software project , regardless of size, complexity


*Process Framework Activities

■ Communication-Communicate with stakeholders and
customers
■ Planning-resources
needed, tasks and risk factors likely to occur, schedule
■ Modeling-Architectural models and design
■ Construction-Generation of code and testing
■ Deployment-completed product is delivered

*Umbrella Activities

■ Software project tracking and control
■ Risk management
■ Software quality assurance (SQA
■ Technical reviews
■ Measurement
■ Software configuration management (SCM)
■ Reusability management
■ Work product preparation and production


*The Essence of Practice

■ General steps in carrying out in software
engineering are
1. Understand the problem through communication.
2. Plan a solution by modeling and software design.
3. Carry out the plan for code generation.
4. Examine the result for accuracy by testing and quality
assurance.


*Hooker’s General Principles

■ 1: The Reason It All Exists : s/w system is required to , provide value
to its user, so before starting any project ask “ Does this add real value to the system “ if
answer is “no” , then do not do it
■ 2: KISS (Keep It Simple, Stupid!) : so easy to maintain and
generate less error
■ 3: Maintain the Vision : without conceptual integrity , a system become
patchwork of incompatible design
■ 4: What You Produce, Others Will Consume
■ 5: Be Open to the Future
■ 6: Plan Ahead for Reuse
■ 7: Think! : placing clear, complete thought before action always produce better
result


*Software Myths

■ Management
 We have standards
We have new computers
 We’ll add more people to catch up
I outsourced it, I’m done
■ Customer
 We have general objectives, let’s start
 Change is easily accommodated
■ Practitioner
 We’ll write it and be done
I can’t assess quality until it is running
 I only need deliver code
 Software engineering is about meaningless documents




**Chapter 2**
■ Process Models

![[Pasted image 20231211142855.png]]
![[Pasted image 20231211142917.png]]
![[Pasted image 20231211142931.png]]

*Iterative Development

⚫ Benefits
 Get-as-you-pay
 feedback for improvement
⚫ Drawbacks
 Architecture/design may not be optimal
 Amount of refactoring may increase
Total cost may increase
⚫ Applicability
where response time is important,
 risk of long projects cannot be taken,
 all req not known
⚫ Execution
 Each iteration is a mini waterfall – decide the specs,
then plan the iteration 
 Length of iteration driven by amount of new
functionality to be added in an iteration

![[Pasted image 20231211143208.png]]

⚫ Advantages
 Requirement will be more stable and more likely to
satisfy user needs
 Early opportunity to explore scale/performance issues
Ability to modify or cancel the project early
Enhanced user engagement
⚫ Disadvantages:
 Potential hit on cost and schedule and Risk
⚫ Applicability:
 When req are hard to elicit
 When confidence in reqs is low
 Where reqs are not well understood
 When design is driven by user needs

![[Pasted image 20231211143313.png]]

